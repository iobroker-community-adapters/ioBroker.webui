import { CssStyleChangeAction } from '../services/undoService/transactionItems/CssStyleChangeAction.js';
import { NodeType } from './NodeType.js';
import { AttributeChangeAction } from '../services/undoService/transactionItems/AttributeChangeAction.js';
import { ExtensionType } from '../widgets/designerView/extensions/ExtensionType.js';
import { CssAttributeParser } from '../helper/CssAttributeParser.js';
import { PropertiesHelper } from '../services/propertiesService/services/PropertiesHelper.js';
import { InsertChildAction } from '../services/undoService/transactionItems/InsertChildAction.js';
import { DomConverter } from '../widgets/designerView/DomConverter.js';
import { enableStylesheetService } from '../widgets/designerView/extensions/buttons/StylesheetServiceDesignViewConfigButtons.js';
import { TypedEvent } from '@node-projects/base-custom-webcomponent';
import { TextContentChangeAction } from '../services/undoService/transactionItems/TextContentChangeAction.js';
import { PropertyChangeAction } from '../services/undoService/transactionItems/PropertyChangeAction.js';
import { deepValue } from '../helper/Helper.js';
export const hideAtDesignTimeAttributeName = 'node-projects-hide-at-design-time';
export const hideAtRunTimeAttributeName = 'node-projects-hide-at-run-time';
export const lockAtDesignTimeAttributeName = 'node-projects-lock-at-design-time';
export const forceHoverAttributeName = 'node-projects-force-hover';
export const forceActiveAttributeName = 'node-projects-force-active';
export const forceVisitedAttributeName = 'node-projects-force-visited';
export const forceFocusAttributeName = 'node-projects-force-focus';
export const forceFocusWithinAttributeName = 'node-projects-force-focus-within';
export const forceFocusVisibleAttributeName = 'node-projects-force-focus-visible';
export class DesignItem {
    lastContainerSize;
    parsedNode;
    node;
    view;
    serviceContainer;
    instanceServiceContainer;
    nodeReplaced = new TypedEvent;
    get window() {
        if (this.isRootItem && this.node instanceof HTMLIFrameElement)
            return this.node.contentDocument.defaultView;
        return (this.node.ownerDocument.defaultView ?? window);
    }
    get document() {
        if (this.isRootItem && this.node instanceof HTMLIFrameElement)
            return this.node.contentDocument;
        return this.node.ownerDocument;
    }
    get usableContainer() {
        if (this.isRootItem && this.element instanceof (this.element.ownerDocument.defaultView ?? window).HTMLIFrameElement)
            return this.element.contentWindow.document;
        else if (this.isRootItem)
            return this.node.shadowRoot;
        return this.element;
    }
    async clone() {
        try {
            const html = DomConverter.ConvertToString([this], false);
            const parsed = await this.serviceContainer.htmlParserService.parse(html, this.serviceContainer, this.instanceServiceContainer, true);
            return parsed[0];
        }
        catch (err) {
            //TODO: clone service for design item, maybe refactor copy&paste to use this also...
            console.warn("could not clone design item.", this);
        }
        return null;
    }
    *allMatching(selectors) {
        if (this.hasChildren) {
            for (let d of this.children()) {
                if (d.nodeType == NodeType.Element && d.element.matches(selectors))
                    yield d;
                yield* d.allMatching(selectors);
            }
        }
    }
    replaceNode(newNode) {
        DesignItem._designItemMap.delete(this.node);
        DesignItem._designItemMap.set(newNode, this);
        if (this.view == this.node)
            this.view = newNode;
        this.node = newNode;
        this.nodeReplaced.emit();
    }
    get nodeType() {
        if (this.node instanceof (this.node.ownerDocument.defaultView ?? window).Comment)
            return NodeType.Comment;
        if (this.node instanceof (this.node.ownerDocument.defaultView ?? window).Text)
            return NodeType.TextNode;
        return NodeType.Element;
    }
    _attributes;
    get hasAttributes() {
        return this._attributes.size > 0;
    }
    hasAttribute(name) {
        return this._attributes.has(name);
    }
    getAttribute(name) {
        return this._attributes.get(name);
    }
    *attributes() {
        for (let s of this._attributes) {
            yield s;
        }
    }
    _withoutUndoSetAttribute(name, value) {
        this._attributes.set(name, value);
        this.serviceContainer.designItemService.handleSpecialAttributes(name, this);
    }
    _withoutUndoRemoveAttribute(name) {
        this._attributes.delete(name);
        this.serviceContainer.designItemService.handleSpecialAttributes(name, this);
    }
    _styles;
    get hasStyles() {
        return this._styles.size > 0;
    }
    hasStyle(name) {
        let nm = name;
        if (!nm.startsWith('--'))
            nm = PropertiesHelper.camelToDashCase(name);
        return this._styles.has(nm);
    }
    getStyle(name) {
        let nm = name;
        if (!nm.startsWith('--'))
            nm = PropertiesHelper.camelToDashCase(name);
        return this._styles.get(nm);
    }
    *styles() {
        for (let s of this._styles) {
            yield s;
        }
    }
    _withoutUndoSetStyle(name, value) {
        let nm = name;
        if (!nm.startsWith('--'))
            nm = PropertiesHelper.camelToDashCase(name);
        this._styles.set(nm, value);
    }
    _withoutUndoRemoveStyle(name) {
        let nm = name;
        if (!nm.startsWith('--'))
            nm = PropertiesHelper.camelToDashCase(name);
        this._styles.delete(nm);
    }
    static _designItemMap = new WeakMap();
    get element() {
        return this.view;
    }
    get name() {
        return this.node.localName;
    }
    get id() {
        return this.element.id;
    }
    set id(value) {
        this.element.id = value;
        if (this.id)
            this.setAttribute("id", value);
        else
            this.removeAttribute("id");
    }
    get isRootItem() {
        return this.instanceServiceContainer.contentService.rootDesignItem === this;
    }
    *childrenRect(selectors) {
        if (this.hasChildren) {
            for (let d of this.children()) {
                if (d.nodeType == NodeType.Element && d.element.matches(selectors))
                    yield d;
                yield* d.allMatching(selectors);
            }
        }
    }
    _childArray = [];
    get hasChildren() {
        return this._childArray.length > 0;
    }
    *children(recursive = false) {
        for (const e of this._childArray) {
            yield e;
            if (recursive) {
                for (const c of e.children(recursive)) {
                    yield c;
                }
            }
        }
    }
    get childCount() {
        return this._childArray.length;
    }
    get firstChild() {
        return this._childArray[0];
    }
    _parent;
    get parent() {
        return this._parent;
    }
    indexOf(designItem) {
        return this._childArray.indexOf(designItem);
    }
    insertAdjacentElement(designItem, where) {
        let action;
        if (where == 'afterbegin') {
            action = new InsertChildAction(designItem, this, 0);
        }
        else if (where == 'beforeend') {
            action = new InsertChildAction(designItem, this, this._childArray.length);
        }
        else if (where == 'beforebegin') {
            action = new InsertChildAction(designItem, this.parent, this.parent.indexOf(this));
        }
        else if (where == 'afterend') {
            action = new InsertChildAction(designItem, this.parent, this.parent.indexOf(this) + 1);
        }
        this.instanceServiceContainer.undoService.execute(action);
    }
    insertChild(designItem, index) {
        const action = new InsertChildAction(designItem, this, index);
        this.instanceServiceContainer.undoService.execute(action);
    }
    removeChild(designItem) {
        this.serviceContainer.deletionService.removeItems([designItem]);
    }
    remove() {
        this.serviceContainer.deletionService.removeItems([this]);
    }
    clearChildren() {
        for (let i = this._childArray.length - 1; i >= 0; i--) {
            let di = this._childArray[i];
            di.remove();
        }
    }
    //abstract text content to own property. so only change via designer api will use it.
    get hasContent() {
        return ((this.nodeType == NodeType.TextNode || this.nodeType == NodeType.Comment) && this.element.textContent != "") || (this._childArray.length === 0);
    }
    get content() {
        if (this.nodeType == NodeType.TextNode || this.nodeType == NodeType.Comment)
            return this.node.textContent;
        else
            return this._childArray.map(x => x.content).join();
    }
    set content(value) {
        const grp = this.openGroup('set content');
        this.clearChildren();
        let t = document.createTextNode(value);
        let di = DesignItem.GetOrCreateDesignItem(t, t, this.serviceContainer, this.instanceServiceContainer);
        if (this.nodeType == NodeType.TextNode) {
            const idx = this.parent.indexOf(this);
            const parent = this.parent;
            this.remove();
            parent.insertChild(di, idx);
        }
        else if (this.nodeType == NodeType.Comment) {
            const action = new TextContentChangeAction(this, value, this.content);
            this.instanceServiceContainer.undoService.execute(action);
        }
        else
            this.insertChild(di);
        grp.commit();
    }
    get innerHTML() {
        return this.element.innerHTML;
    }
    set innerHTML(value) {
        if (this.nodeType != NodeType.TextNode) {
            const grp = this.openGroup('set innerHTML');
            this.clearChildren();
            const range = document.createRange();
            range.selectNode(document.body);
            const fragment = range.createContextualFragment(value);
            for (const n of [...fragment.childNodes]) {
                let di = DesignItem.createDesignItemFromInstance(n, this.serviceContainer, this.instanceServiceContainer);
                this.insertChild(di);
            }
            grp.commit();
        }
    }
    get isEmptyTextNode() {
        return this.nodeType === NodeType.TextNode && this.content?.trim() == '';
    }
    get hideAtDesignTime() {
        return this.hasAttribute(hideAtDesignTimeAttributeName);
    }
    set hideAtDesignTime(value) {
        if (value)
            this.setAttribute(hideAtDesignTimeAttributeName, "");
        else
            this.removeAttribute(hideAtDesignTimeAttributeName);
    }
    get hideAtRunTime() {
        return this.hasAttribute(hideAtRunTimeAttributeName);
    }
    set hideAtRunTime(value) {
        if (value)
            this.setAttribute(hideAtRunTimeAttributeName, "");
        else
            this.removeAttribute(hideAtRunTimeAttributeName);
    }
    get lockAtDesignTime() {
        return this.hasAttribute(lockAtDesignTimeAttributeName);
    }
    set lockAtDesignTime(value) {
        if (value)
            this.setAttribute(lockAtDesignTimeAttributeName, "");
        else
            this.removeAttribute(lockAtDesignTimeAttributeName);
    }
    static createDesignItemFromInstance(node, serviceContainer, instanceServiceContainer) {
        let designItem = serviceContainer.designItemService.createDesignItem(node, node, serviceContainer, instanceServiceContainer);
        if (node instanceof (node.ownerDocument.defaultView ?? window).HTMLTemplateElement && node.getAttribute('shadowrootmode') == 'open') {
            try {
                const shadow = node.parentNode.attachShadow({ mode: 'open' });
                shadow.appendChild(node.content.cloneNode(true));
            }
            catch (err) {
                console.error("error attaching shadowdom", err);
            }
        }
        if (designItem.nodeType == NodeType.Element) {
            for (let a of designItem.element.attributes) {
                if (a.name !== 'style') {
                    designItem._attributes.set(a.name, a.value);
                }
            }
            if (node instanceof (node.ownerDocument.defaultView ?? window).HTMLElement || node instanceof (node.ownerDocument.defaultView ?? window).SVGElement) {
                const cssParser = new CssAttributeParser();
                const st = node.getAttribute("style");
                if (st) {
                    cssParser.parse(st);
                    for (let e of cssParser.entries) {
                        designItem._styles.set(e.name, e.value);
                    }
                }
                serviceContainer.designItemService.handleSpecialAttributes(lockAtDesignTimeAttributeName, designItem);
            }
            node.draggable = false; //even if it should be true, for better designer exp.
        }
        designItem._childArray = designItem._internalUpdateChildrenFromNodesChildren();
        for (let c of designItem._childArray) {
            c._parent = designItem;
        }
        return designItem;
    }
    querySelectorAll(selectors) {
        return this.usableContainer.querySelectorAll(selectors);
    }
    removeDesignerAttributesAndStylesFromChildren() {
        const els = this.querySelectorAll('*');
        for (let e of els) {
            const di = DesignItem.GetDesignItem(e);
            if (!di.hasAttribute("draggable"))
                e.removeAttribute("draggable");
            if (!di.hasStyle("pointer-events"))
                e.style.pointerEvents = '';
        }
    }
    updateChildrenFromNodesChildren() {
        this._childArray = this._internalUpdateChildrenFromNodesChildren();
        for (let c of this._childArray) {
            c._parent = this;
        }
    }
    _internalUpdateChildrenFromNodesChildren() {
        const newChilds = [];
        if (this.nodeType == NodeType.Element) {
            if (this.element instanceof (this.node.ownerDocument.defaultView ?? window).HTMLTemplateElement) {
                for (const c of this.element.content.childNodes) {
                    const di = DesignItem.createDesignItemFromInstance(c, this.serviceContainer, this.instanceServiceContainer);
                    newChilds.push(di);
                }
            }
            else if (this.isRootItem && this.element instanceof (this.node.ownerDocument.defaultView ?? window).HTMLIFrameElement) {
                for (const c of this.element.contentWindow.document.childNodes) {
                    const di = DesignItem.createDesignItemFromInstance(c, this.serviceContainer, this.instanceServiceContainer);
                    newChilds.push(di);
                }
            }
            else {
                for (const c of this.element.childNodes) {
                    const di = DesignItem.createDesignItemFromInstance(c, this.serviceContainer, this.instanceServiceContainer);
                    newChilds.push(di);
                }
            }
        }
        return newChilds;
    }
    _backupWhenEditContent;
    _inEditContent = false;
    editContent() {
        this._inEditContent = true;
        this._backupWhenEditContent = [...this.element.childNodes];
        const nn = this.element.innerHTML;
        this.element.innerHTML = '';
        this.element.innerHTML = nn;
        this.element.setAttribute('contenteditable', '');
    }
    editContentFinish() {
        if (this._inEditContent) {
            this._inEditContent = false;
            this.element.removeAttribute('contenteditable');
            this.element.innerHTML = '';
            for (let n of this._backupWhenEditContent) {
                this.element.appendChild(n);
            }
            this._backupWhenEditContent = null;
        }
    }
    constructor(node, parsedNode, serviceContainer, instanceServiceContainer) {
        this.node = node;
        this.view = node;
        this.parsedNode = parsedNode;
        this.serviceContainer = serviceContainer;
        this.instanceServiceContainer = instanceServiceContainer;
        this._attributes = new Map();
        this._styles = new Map();
        DesignItem._designItemMap.set(node, this);
    }
    setView(node) {
        this.view = node;
        DesignItem._designItemMap.set(node, this);
    }
    openGroup(title) {
        return this.instanceServiceContainer.undoService.openGroup(title);
    }
    getOrCreateDesignItem(node) {
        return DesignItem.GetOrCreateDesignItem(node, node, this.serviceContainer, this.instanceServiceContainer);
    }
    static GetOrCreateDesignItem(node, parsedNode, serviceContainer, instanceServiceContainer) {
        if (!node)
            return null;
        let designItem = DesignItem._designItemMap.get(node);
        if (!designItem) {
            let dis = serviceContainer.designItemService;
            designItem = dis.createDesignItem(node, parsedNode, serviceContainer, instanceServiceContainer);
        }
        return designItem;
    }
    static GetDesignItem(node) {
        if (!node)
            return null;
        let designItem = DesignItem._designItemMap.get(node);
        return designItem;
    }
    setStyle(name, value, important) {
        let nm = name;
        if (!nm.startsWith('--'))
            nm = PropertiesHelper.camelToDashCase(name);
        if (this.isRootItem) {
            throw 'not allowed to set style on root item or use async setStyle';
        }
        else {
            const action = new CssStyleChangeAction(this, nm, value, this._styles.get(nm));
            this.instanceServiceContainer.undoService.execute(action);
        }
    }
    async setStyleAsync(name, value, important) {
        let nm = name;
        if (!nm.startsWith('--'))
            nm = PropertiesHelper.camelToDashCase(name);
        //TODO: remove this special case (I think), should be in CSSSytleChangeAction.
        //Maybe we should be able to set a setscope (sheet, local, pseudo selctor, ...)
        if (this.isRootItem) {
            if (!this.instanceServiceContainer.stylesheetService)
                throw 'not allowed to set style on root item';
            else {
                let decls = this.instanceServiceContainer.stylesheetService.getDeclarationsSortedBySpecificity(this, name);
                if (decls !== null && decls.length > 0) {
                    this.instanceServiceContainer.stylesheetService.updateDeclarationValue(decls[0], value, important);
                }
                else {
                    let rules = this.instanceServiceContainer.stylesheetService.getRules(':host').filter(x => !x.stylesheet?.readOnly);
                    if (decls === null || rules.length === 0) {
                        const cg = this.openGroup('add rule and set style: ' + name);
                        const sheets = this.instanceServiceContainer.stylesheetService.getStylesheets();
                        const rule = await this.instanceServiceContainer.stylesheetService.addRule(sheets[0], ':host');
                        this.instanceServiceContainer.stylesheetService.insertDeclarationIntoRule(rule, name, value, important);
                        cg.commit();
                    }
                    else {
                        this.instanceServiceContainer.stylesheetService.insertDeclarationIntoRule(rules[0], name, value, important);
                    }
                }
            }
        }
        else {
            const action = new CssStyleChangeAction(this, nm, value, this._styles.get(nm));
            this.instanceServiceContainer.undoService.execute(action);
        }
    }
    removeStyle(name) {
        let nm = name;
        if (!nm.startsWith('--'))
            nm = PropertiesHelper.camelToDashCase(name);
        const action = new CssStyleChangeAction(this, nm, '', this._styles.get(nm));
        this.instanceServiceContainer.undoService.execute(action);
    }
    updateStyleInSheetOrLocal(name, value, important, forceSet) {
        let nm = name;
        if (!nm.startsWith('--'))
            nm = PropertiesHelper.camelToDashCase(name);
        let declarations = this.instanceServiceContainer.stylesheetService?.getDeclarationsSortedBySpecificity(this, nm).filter(x => !x.stylesheet?.readOnly);
        if (this.hasStyle(name) || this.instanceServiceContainer.designContext.extensionOptions[enableStylesheetService] === false || !declarations?.length) {
            // Set style locally
            if (this.getStyle(nm) != value || forceSet) {
                this.setStyle(nm, value);
            }
            else if (value == null) {
                this.removeStyle(nm);
            }
        }
        else {
            this.instanceServiceContainer.stylesheetService.updateDeclarationValue(declarations[0], value, false);
        }
    }
    async updateStyleInSheetOrLocalAsync(name, value, important, forceSet) {
        let nm = name;
        if (!nm.startsWith('--'))
            nm = PropertiesHelper.camelToDashCase(name);
        let declarations = this.instanceServiceContainer.stylesheetService?.getDeclarationsSortedBySpecificity(this, nm).filter(x => !x.stylesheet?.readOnly);
        if (this.hasStyle(name) || this.instanceServiceContainer.designContext.extensionOptions[enableStylesheetService] === false || !declarations?.length) {
            // Set style locally
            if (this.getStyle(nm) != value || forceSet) {
                await this.setStyleAsync(nm, value);
            }
            else if (value == null) {
                this.removeStyle(nm);
            }
        }
        else {
            this.instanceServiceContainer.stylesheetService.updateDeclarationValue(declarations[0], value, false);
        }
    }
    getStyleFromSheetOrLocal(name, fallback = null) {
        let nm = name;
        if (!nm.startsWith('--'))
            nm = PropertiesHelper.camelToDashCase(name);
        if (this.hasStyle(name))
            // Get style locally
            return this.getStyle(nm);
        let decls = this.instanceServiceContainer.stylesheetService?.getDeclarationsSortedBySpecificity(this, nm);
        if (decls && decls.length > 0)
            return decls[0].value;
        return null;
    }
    getStyleFromSheetOrLocalOrComputed(name, fallback = null) {
        let nm = name;
        if (!nm.startsWith('--'))
            nm = PropertiesHelper.camelToDashCase(name);
        let value = this.getStyleFromSheetOrLocal(nm);
        if (!value) {
            value = getComputedStyle(this.element).getPropertyValue(nm);
        }
        return value ?? fallback;
    }
    getComputedStyleProperty(name, fallback = null) {
        let nm = name;
        if (!nm.startsWith('--'))
            nm = PropertiesHelper.camelToDashCase(name);
        let value = this.getStyleFromSheetOrLocal(nm);
        if (!value) {
            value = getComputedStyle(this.element).getPropertyValue(nm);
        }
        return value ?? fallback;
    }
    getComputedStyle() {
        if (this.nodeType == NodeType.Element)
            return this.window.getComputedStyle(this.element);
        return null;
    }
    _stylesCache = null;
    _cacheClearTimer;
    getAllStyles() {
        let styles = this._stylesCache;
        if (styles)
            return styles;
        if (this.nodeType != NodeType.Element)
            return [];
        const localStyles = [...this._styles.entries()].map(x => ({ name: x[0], value: x[1], important: false, parent: null }));
        if (this.instanceServiceContainer.stylesheetService) {
            try {
                const rules = this.instanceServiceContainer.stylesheetService?.getAppliedRules(this);
                if (rules) {
                    return [{ selector: null, declarations: localStyles, specificity: null, stylesheet: null }, ...rules];
                }
            }
            catch (err) {
                console.warn('getAppliedRules', err);
            }
        }
        styles = [{ selector: null, declarations: localStyles, specificity: null, stylesheet: null }];
        this._stylesCache = styles;
        clearTimeout(this._cacheClearTimer);
        this._cacheClearTimer = setTimeout(() => this._stylesCache = null, 30);
        return styles;
    }
    setAttribute(name, value) {
        if (this.isRootItem)
            throw 'not allowed to set attribute on root item';
        const action = new AttributeChangeAction(this, name, value, this._attributes.get(name));
        this.instanceServiceContainer.undoService.execute(action);
    }
    removeAttribute(name) {
        const action = new AttributeChangeAction(this, name, null, this._attributes.get(name));
        this.instanceServiceContainer.undoService.execute(action);
    }
    // todo : public setPropertyAndAttrbute()
    //getProperty ...
    setProperty(name, value) {
        if (this.isRootItem)
            throw 'not allowed to set attribute on root item';
        const oldValue = deepValue(this.node, name);
        const action = new PropertyChangeAction(this, name, value, oldValue);
        this.instanceServiceContainer.undoService.execute(action);
    }
    // Internal implementations wich don't use undo/redo
    _insertChildInternal(designItem, index) {
        if (designItem.parent && this.instanceServiceContainer.selectionService.primarySelection == designItem) {
            designItem.instanceServiceContainer.designerCanvas.extensionManager.removeExtension(designItem.parent, ExtensionType.PrimarySelectionContainer);
            designItem.instanceServiceContainer.designerCanvas.extensionManager.removeExtension(designItem.parent, ExtensionType.PrimarySelectionContainerAndCanBeEntered);
        }
        if (designItem.parent) {
            designItem.parent._removeChildInternal(designItem);
        }
        if (index == null || this._childArray.length == 0 || index >= this._childArray.length) {
            this._childArray.push(designItem);
            if (this.isRootItem) {
                if (this.usableContainer?.children[0] instanceof this.window.HTMLHtmlElement)
                    this.usableContainer.children[0].remove();
                this.usableContainer.appendChild(designItem.view);
            }
            else if (this.view instanceof (this.node.ownerDocument.defaultView ?? window).HTMLTemplateElement) {
                this.view.content.appendChild(designItem.view);
            }
            else
                this.view.appendChild(designItem.view);
        }
        else {
            let el = this._childArray[index];
            if (this.isRootItem) {
                if (this.usableContainer?.children[0] instanceof this.window.HTMLHtmlElement)
                    this.usableContainer.children[0].remove();
                this.usableContainer.insertBefore(designItem.view, el.element);
            }
            else if (this.view instanceof (this.node.ownerDocument.defaultView ?? window).HTMLTemplateElement) {
                this.view.content.insertBefore(designItem.view, el.element);
            }
            else
                this.view.insertBefore(designItem.view, el.element);
            this._childArray.splice(index, 0, designItem);
        }
        designItem._parent = this;
        //TODO: is this still needed???
        if (this.instanceServiceContainer.selectionService.primarySelection == designItem) {
            designItem.instanceServiceContainer.designerCanvas.extensionManager.applyExtension(designItem.parent, ExtensionType.PrimarySelectionContainer);
            if (designItem.getPlacementService().isEnterableContainer(this))
                designItem.instanceServiceContainer.designerCanvas.extensionManager.applyExtension(designItem.parent, ExtensionType.PrimarySelectionContainerAndCanBeEntered);
        }
        this._refreshIfStyleSheet();
    }
    _removeChildInternal(designItem) {
        if (designItem.parent && this.instanceServiceContainer.selectionService.primarySelection == designItem) {
            designItem.instanceServiceContainer.designerCanvas.extensionManager.removeExtension(designItem.parent, ExtensionType.PrimarySelectionContainer);
            designItem.instanceServiceContainer.designerCanvas.extensionManager.removeExtension(designItem.parent, ExtensionType.PrimarySelectionAndCanBeEntered);
        }
        designItem.instanceServiceContainer.designerCanvas.extensionManager.removeExtensions([designItem], true);
        const index = this._childArray.indexOf(designItem);
        if (index > -1) {
            this._childArray.splice(index, 1);
            designItem.element.remove();
            designItem._parent = null;
        }
        this._refreshIfStyleSheet();
    }
    _refreshIfStyleSheet() {
        if (this.name == 'style' || this.parent?.name == 'style') {
            //Update Stylesheetservice with sheet info
            //Patch this sheetdata
            //TODO: do not patch styles in templates, this needs to be recursive, cause the style does not need to be on the root
            /*const realContent = this._childArray.reduce((a, b) => a + b.content, '');
            this.view.textContent = AbstractStylesheetService.buildPatchedStyleSheet([cssFromString(realContent)]);
            this.instanceServiceContainer.designerCanvas.lazyTriggerReparseDocumentStylesheets();*/
        }
        else if (this.name == 'link') {
        }
    }
    getPlacementService(style) {
        if (this.nodeType != NodeType.Element)
            return null;
        style ??= getComputedStyle(this.element);
        return this.serviceContainer.getLastServiceWhere('containerService', x => x.serviceForContainer(this, style));
    }
    static createDesignItemFromImageBlob(serviceContainer, instanceServiceContainer, data) {
        return new Promise(resolve => {
            let reader = new FileReader();
            reader.onloadend = () => {
                const img = document.createElement('img');
                img.src = reader.result;
                const di = DesignItem.createDesignItemFromInstance(img, serviceContainer, instanceServiceContainer);
                return resolve(di);
            };
            reader.readAsDataURL(data);
        });
    }
    get hasForcedCss() {
        return this.cssForceHover || this.cssForceActive || this.cssForceVisited || this.cssForceFocus || this.cssForceFocusWithin || this.cssForceFocusVisible;
    }
    get cssForceHover() {
        return this.element.hasAttribute(forceHoverAttributeName);
    }
    set cssForceHover(value) {
        if (value)
            this.element.setAttribute(forceHoverAttributeName, '');
        else
            this.element.removeAttribute(forceHoverAttributeName);
        this.instanceServiceContainer.contentService.onContentChanged.emit({ changeType: 'changed', designItems: [this] });
    }
    get cssForceActive() {
        return this.element.hasAttribute(forceActiveAttributeName);
    }
    set cssForceActive(value) {
        if (value)
            this.element.setAttribute(forceActiveAttributeName, '');
        else
            this.element.removeAttribute(forceActiveAttributeName);
        this.instanceServiceContainer.contentService.onContentChanged.emit({ changeType: 'changed', designItems: [this] });
    }
    get cssForceVisited() {
        return this.element.hasAttribute(forceVisitedAttributeName);
    }
    set cssForceVisited(value) {
        if (value)
            this.element.setAttribute(forceVisitedAttributeName, '');
        else
            this.element.removeAttribute(forceVisitedAttributeName);
        this.instanceServiceContainer.contentService.onContentChanged.emit({ changeType: 'changed', designItems: [this] });
    }
    get cssForceFocus() {
        return this.element.hasAttribute(forceFocusAttributeName);
    }
    set cssForceFocus(value) {
        if (value)
            this.element.setAttribute(forceFocusAttributeName, '');
        else
            this.element.removeAttribute(forceFocusAttributeName);
        this.instanceServiceContainer.contentService.onContentChanged.emit({ changeType: 'changed', designItems: [this] });
    }
    get cssForceFocusWithin() {
        return this.element.hasAttribute(forceFocusWithinAttributeName);
    }
    set cssForceFocusWithin(value) {
        if (value)
            this.element.setAttribute(forceFocusWithinAttributeName, '');
        else
            this.element.removeAttribute(forceFocusWithinAttributeName);
        this.instanceServiceContainer.contentService.onContentChanged.emit({ changeType: 'changed', designItems: [this] });
    }
    get cssForceFocusVisible() {
        return this.element.hasAttribute(forceFocusVisibleAttributeName);
    }
    set cssForceFocusVisible(value) {
        if (value)
            this.element.setAttribute(forceFocusVisibleAttributeName, '');
        else
            this.element.removeAttribute(forceFocusVisibleAttributeName);
        this.instanceServiceContainer.contentService.onContentChanged.emit({ changeType: 'changed', designItems: [this] });
    }
}
//# sourceMappingURL=DesignItem.js.map