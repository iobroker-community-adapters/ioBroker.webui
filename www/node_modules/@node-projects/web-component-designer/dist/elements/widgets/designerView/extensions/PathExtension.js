import { AbstractExtension } from './AbstractExtension.js';
import '../../../helper/PathDataPolyfill.js';
export class PathExtension extends AbstractExtension {
    //private _itemRect: DOMRect;
    //private _svgRect: DOMRect;
    _lastPos;
    _parentRect;
    constructor(extensionManager, designerView, extendedItem) {
        super(extensionManager, designerView, extendedItem);
    }
    extend() {
        //this._itemRect = this.extendedItem.element.getBoundingClientRect();
        //this._svgRect = (<SVGGeometryElement>this.extendedItem.element).ownerSVGElement.getBoundingClientRect();
        this._parentRect = this.extendedItem.element.parentElement.getBoundingClientRect();
        const pathdata = this.extendedItem.node.getPathData({ normalize: true });
        for (let p of pathdata) {
            switch (p.type) {
                case 'M':
                    this._drawPathCircle(p.values[0], p.values[1]);
                    this._lastPos = { x: p.values[0], y: p.values[1] };
                    break;
                case 'L':
                    this._drawPathCircle(p.values[0], p.values[1]);
                    break;
                case 'H':
                    break;
                case 'V':
                    break;
                case 'Z':
                    break;
                case 'C':
                    this._drawPathLine(this._lastPos.x, this._lastPos.y, p.values[0], p.values[1]);
                    this._drawPathLine(p.values[4], p.values[5], p.values[2], p.values[3]);
                    this._drawPathCircle(p.values[0], p.values[1]);
                    this._drawPathCircle(p.values[2], p.values[3]);
                    this._drawPathCircle(p.values[4], p.values[5]);
                    this._lastPos = { x: p.values[4], y: p.values[5] };
                    break;
                case 'c':
                    this._drawPathLine(this._lastPos.x, this._lastPos.y, p.values[0], p.values[1]);
                    this._drawPathLine(this._lastPos.x + p.values[4], this._lastPos.y + p.values[5], p.values[2], p.values[3]);
                    this._drawPathCircle(p.values[0], p.values[1]);
                    this._drawPathCircle(p.values[2], p.values[3]);
                    this._drawPathCircle(this._lastPos.x + p.values[4], this._lastPos.y + p.values[5]);
                    this._lastPos = { x: p.values[4], y: p.values[5] };
                    break;
                case 'S':
                    this._drawPathCircle(p.values[0], p.values[1]);
                    this._drawPathCircle(p.values[2], p.values[3]);
                    break;
                case 'Q':
                    this._drawPathCircle(p.values[0], p.values[1]);
                    this._drawPathCircle(p.values[2], p.values[3]);
                    break;
                case 'T':
                    this._drawPathCircle(p.values[0], p.values[1]);
                    break;
                case 'A':
                    this._drawPathCircle(p.values[0], p.values[1]);
                    this._drawPathCircle(p.values[5], p.values[6]);
                    break;
            }
        }
    }
    _drawPathCircle(x, y) {
        this._drawCircle(this._parentRect.x - this.designerCanvas.containerBoundingRect.x + x, this._parentRect.y - this.designerCanvas.containerBoundingRect.y + y, 3, 'svg-path');
    }
    _drawPathLine(x1, y1, x2, y2) {
        this._drawLine(this._parentRect.x - this.designerCanvas.containerBoundingRect.x + x1, this._parentRect.y - this.designerCanvas.containerBoundingRect.y + y1, this._parentRect.x - this.designerCanvas.containerBoundingRect.x + x2, this._parentRect.y - this.designerCanvas.containerBoundingRect.y + y2, 'svg-path-line');
    }
    refresh() {
        this._removeAllOverlays();
        this.extend();
    }
    dispose() {
        this._removeAllOverlays();
    }
}
