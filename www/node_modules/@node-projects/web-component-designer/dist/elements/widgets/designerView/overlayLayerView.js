import { css, html, BaseCustomWebComponentConstructorAppend } from '/webui/node_modules/@node-projects/base-custom-webcomponent/./dist/index.js';
import { OverlayLayer } from './extensions/OverlayLayer.js';
export class OverlayLayerView extends BaseCustomWebComponentConstructorAppend {
    static template = html `
    <svg id="svg" style="pointer-events: none;">
      <g id="background"></g>
      <g id="normal"></g>
      <g id="foreground"></g>
    </svg>`;
    static style = css `
    svg {
      width: 100%;
      height: 100%;
      overflow: visible;
    }

    .svg-snapline { stroke: purple; stroke-dasharray: 4; fill: transparent; }
    .svg-selector { stroke: black; fill: #3899ec55; stroke-width: 1; stroke-dasharray: 2; }
    .svg-primary-selection-move { stroke: #3899ec; fill: #3899ec; cursor: move; pointer-events: all }
    .svg-position  { stroke: black; stroke-dasharray: 2; }
    .svg-path { stroke: #3899ec; fill: orange; pointer-events: all }
    .svg-path-line { stroke: #3899ec; stroke-dasharray: 2; }
    .svg-draw-new-element { stroke: black; fill: transparent; stroke-width: 1; }`;
    static is = 'node-projects-overlay-layer-view';
    _serviceContainer;
    _svg;
    _gBackground;
    _gNormal;
    _gForeground;
    constructor(serviceContainer) {
        super();
        this._serviceContainer = serviceContainer;
        this._svg = this._getDomElement('svg');
        this._gBackground = this._getDomElement('background');
        this._gNormal = this._getDomElement('normal');
        this._gForeground = this._getDomElement('foreground');
        this._initialize();
    }
    _initialize() {
        let styles = [OverlayLayerView.style];
        for (const extList of this._serviceContainer.designerExtensions) {
            for (const ext of extList[1]) {
                if (ext.style) {
                    styles.push(ext.style);
                }
            }
        }
        for (const ext of this._serviceContainer.designerPointerExtensions) {
            if (ext.style) {
                styles.push(ext.style);
            }
        }
        this.shadowRoot.adoptedStyleSheets = styles;
    }
    addOverlay(element, overlayLayer = OverlayLayer.Normal) {
        switch (overlayLayer) {
            case OverlayLayer.Background:
                this._gBackground.appendChild(element);
                break;
            case OverlayLayer.Foregorund:
                this._gForeground.appendChild(element);
                break;
            default:
                this._gNormal.appendChild(element);
                break;
        }
    }
    removeOverlay(element) {
        try {
            if (element)
                element.parentElement.removeChild(element);
        }
        catch (err) {
            console.error(err);
        }
    }
    removeAllNodesWithClass(className) {
        const nodes = this._svg.querySelectorAll('.' + className);
        for (const e of nodes) {
            e.parentNode.removeChild(e);
        }
    }
    removeAllOverlays() {
        const nodes = this._svg.querySelectorAll('svg > g > *');
        for (const e of nodes) {
            e.parentNode.removeChild(e);
        }
    }
    createPoint() {
        //@ts-ignore
        return this._svg.createSVGPoint();
    }
    elementFromPoint(x, y) {
        //@ts-ignore
        return this.shadowRoot.elementFromPoint(x, y);
    }
    drawLine(x1, y1, x2, y2, className, line, overlayLayer) {
        if (!line) {
            line = document.createElementNS("http://www.w3.org/2000/svg", "line");
            this.addOverlay(line, overlayLayer);
        }
        line.setAttribute('x1', x1);
        line.setAttribute('y1', y1);
        line.setAttribute('x2', x2);
        line.setAttribute('y2', y2);
        if (className)
            line.setAttribute('class', className);
        return line;
    }
    drawCircle(x, y, radius, className, circle, overlayLayer) {
        if (!circle) {
            circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            this.addOverlay(circle, overlayLayer);
        }
        circle.setAttribute('cx', x);
        circle.setAttribute('cy', y);
        circle.setAttribute('r', radius);
        if (className)
            circle.setAttribute('class', className);
        return circle;
    }
    drawRect(x, y, w, h, className, rect, overlayLayer) {
        if (!rect) {
            rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
            this.addOverlay(rect, overlayLayer);
        }
        rect.setAttribute('x', x);
        rect.setAttribute('y', y);
        rect.setAttribute('width', w);
        rect.setAttribute('height', h);
        if (className)
            rect.setAttribute('class', className);
        return rect;
    }
    drawText(text, x, y, className, textEl, overlayLayer) {
        if (!textEl) {
            textEl = document.createElementNS("http://www.w3.org/2000/svg", "text");
            this.addOverlay(textEl, overlayLayer);
        }
        textEl.setAttribute('x', x);
        textEl.setAttribute('y', y);
        textEl.textContent = text;
        if (className)
            textEl.setAttribute('class', className);
        return textEl;
    }
}
customElements.define(OverlayLayerView.is, OverlayLayerView);
