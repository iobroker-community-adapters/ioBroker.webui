import { EventNames } from '../../../../enums/EventNames.js';
import { AbstractExtension } from './AbstractExtension.js';
export class TransformOriginExtension extends AbstractExtension {
    _startPos;
    _circle;
    _circle2;
    constructor(extensionManager, designerView, extendedItem) {
        super(extensionManager, designerView, extendedItem);
    }
    extend() {
        const rect = this.extendedItem.element.getBoundingClientRect();
        const computed = getComputedStyle(this.extendedItem.element);
        const to = computed.transformOrigin.split(' ');
        this._circle = this._drawCircle((rect.x - this.designerCanvas.containerBoundingRect.x) / this.designerCanvas.scaleFactor + Number.parseFloat(to[0].replace('px', '')), (rect.y - this.designerCanvas.containerBoundingRect.y) / this.designerCanvas.scaleFactor + Number.parseFloat(to[1].replace('px', '')), 5, 'svg-transform-origin');
        this._circle.setAttribute('style', 'cursor: pointer');
        this._circle2 = this._drawCircle((rect.x - this.designerCanvas.containerBoundingRect.x) / this.designerCanvas.scaleFactor + Number.parseFloat(to[0].replace('px', '')), (rect.y - this.designerCanvas.containerBoundingRect.y) / this.designerCanvas.scaleFactor + Number.parseFloat(to[1].replace('px', '')), 1, 'svg-transform-origin');
        this._circle2.setAttribute('style', 'pointer-events: none');
        this._circle.addEventListener(EventNames.PointerDown, event => this.pointerEvent(event));
        this._circle.addEventListener(EventNames.PointerMove, event => this.pointerEvent(event));
        this._circle.addEventListener(EventNames.PointerUp, event => this.pointerEvent(event)); //TODO: -> assign to window
    }
    pointerEvent(event) {
        event.stopPropagation();
        const rect = this.extendedItem.element.getBoundingClientRect();
        const computed = getComputedStyle(this.extendedItem.element);
        const to = computed.transformOrigin.split(' ');
        switch (event.type) {
            case EventNames.PointerDown:
                event.target.setPointerCapture(event.pointerId);
                this._startPos = { x: event.x, y: event.y };
                break;
            case EventNames.PointerMove:
                if (this._startPos && event.buttons > 0) {
                    const dx = event.x - this._startPos.x;
                    const dy = event.y - this._startPos.y;
                    this._circle.setAttribute('cx', (rect.x - this.designerCanvas.containerBoundingRect.x + Number.parseFloat(to[0].replace('px', '')) + dx));
                    this._circle.setAttribute('cy', (rect.y - this.designerCanvas.containerBoundingRect.y + Number.parseFloat(to[1].replace('px', '')) + dy));
                    this._circle2.setAttribute('cx', (rect.x - this.designerCanvas.containerBoundingRect.x + Number.parseFloat(to[0].replace('px', '')) + dx));
                    this._circle2.setAttribute('cy', (rect.y - this.designerCanvas.containerBoundingRect.y + Number.parseFloat(to[1].replace('px', '')) + dy));
                }
                break;
            case EventNames.PointerUp:
                event.target.releasePointerCapture(event.pointerId);
                if (this._startPos) {
                    const dx = event.x - this._startPos.x;
                    const dy = event.y - this._startPos.y;
                    const x = Number.parseFloat(to[0].replace('px', ''));
                    const y = Number.parseFloat(to[1].replace('px', ''));
                    const newX = (dx + x);
                    const newY = (dy + y);
                    const przX = Math.round(newX / rect.width * 10000) / 100; //round to 2 decimal places
                    const przY = Math.round(newY / rect.height * 10000) / 100;
                    //this.extendedItem.setStyle('transform-origin',newX + 'px ' + newY + 'px');
                    this.extendedItem.setStyle('transform-origin', przX + '% ' + przY + '%');
                    this.refresh();
                    this._startPos = null;
                }
                break;
        }
    }
    refresh() {
        this._removeAllOverlays();
        this.extend();
    }
    dispose() {
        this._removeAllOverlays();
    }
}
