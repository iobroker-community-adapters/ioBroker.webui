import { DesignItem } from '../../item/DesignItem.js';
import { CssAttributeParser } from '../../helper/CssAttributeParser.js';
import { newElementFromString } from '../../helper/ElementHelper.js';
import * as esprima from '/webui/node_modules/esprima-next/dist/esm/esprima.js';
function* getChildNodes(node) {
    switch (node.type) {
        case esprima.Syntax.Program:
            yield node.body;
            break;
        case esprima.Syntax.ClassDeclaration:
            yield node.body;
            break;
        case esprima.Syntax.MethodDefinition:
            yield node.value;
            break;
    }
}
// Alternative Parser, cause when you use the Browser, it instanciates the CusomElements, and some Elemnts remove
// attributes from their DOM, so you loose Data
export class AbstractClassElementParserService {
    _parserUrl;
    _esprimaUrl;
    constructor(parserUrl = '../../../../../node-html-parser-esm/dist/index.js', esprimaUrl = '../../../../../esprima-next/dist/esm/esprima.js') {
        this._parserUrl = parserUrl;
        this._esprimaUrl = esprimaUrl;
    }
    async parse(module, serviceContainer, instanceServiceContainer) {
        let esprima = await import(this._esprimaUrl);
        const parsedModule = esprima.parseModule(module);
        const classDecl = parsedModule.body.find(x => x.type == esprima.Syntax.ClassDeclaration);
        const renderMethod = classDecl.body.body.find(x => x.type == esprima.Syntax.MethodDefinition && x.key.name == 'render');
        const renderMethodStatement = renderMethod.value.body.body[0];
        const taggedTemplate = renderMethodStatement.argument;
        const templateLiteral = taggedTemplate.quasi;
        const html = templateLiteral.quasis.map(x => x.value.raw).join();
        //@ts-ignore
        let parser = await import(this._parserUrl);
        const parsed = parser.parse(html, { comment: true });
        let designItems = [];
        for (let p of parsed.childNodes) {
            let di = this._createDesignItemsRecursive(p, serviceContainer, instanceServiceContainer, null);
            if (di != null)
                designItems.push(di);
            else
                console.warn("NodeHtmlParserService - could not parse element", p);
        }
        return designItems;
    }
    _parseDiv = document.createElement("div");
    _createDesignItemsRecursive(item, serviceContainer, instanceServiceContainer, namespace) {
        let designItem = null;
        if (item.nodeType == 1) {
            let element;
            let manualCreatedElement = false;
            if (!namespace)
                element = newElementFromString('<' + item.rawTagName + ' ' + item.rawAttrs + '></' + item.rawTagName + '>'); // some custom elements only parse attributes during constructor call 
            if (!element) {
                if (namespace)
                    element = document.createElementNS(namespace, item.rawTagName);
                else
                    element = document.createElement(item.rawTagName);
                manualCreatedElement = true;
            }
            designItem = new DesignItem(element, item, serviceContainer, instanceServiceContainer);
            let hideAtDesignTime = false;
            let hideAtRunTime = false;
            let lockAtDesignTime = false;
            let style = '';
            let attr = item.attributes;
            for (let a in attr) {
                if (a !== 'style') {
                    designItem._withoutUndoSetAttribute(a, attr[a]);
                    if (manualCreatedElement) {
                        element.setAttribute(a, attr[a]);
                    }
                    if (a === 'node-projects-hide-at-design-time')
                        hideAtDesignTime = true;
                    else if (a === 'node-projects-hide-at-run-time')
                        hideAtRunTime = true;
                    else if (a === 'node-projects-lock-at-design-time')
                        lockAtDesignTime = true;
                }
                else {
                    style = attr[a];
                }
            }
            if ((element instanceof HTMLElement || element instanceof SVGElement) && style) {
                let styleParser = new CssAttributeParser();
                styleParser.parse(style);
                for (let s of styleParser.entries) {
                    designItem._withoutUndoSetStyle(s.name, s.value);
                    if (manualCreatedElement) {
                        element.style[s.name] = s.value;
                    }
                }
            }
            if (!lockAtDesignTime && (element instanceof HTMLElement || element instanceof SVGElement)) {
                requestAnimationFrame(() => element.style.pointerEvents = 'auto');
            }
            designItem.hideAtDesignTime = hideAtDesignTime;
            designItem.hideAtRunTime = hideAtRunTime;
            designItem.lockAtDesignTime = lockAtDesignTime;
            element.draggable = false; //even if it should be true, for better designer exp.
            for (let c of item.childNodes) {
                let di = this._createDesignItemsRecursive(c, serviceContainer, instanceServiceContainer, element instanceof SVGElement ? 'http://www.w3.org/2000/svg' : null);
                designItem._insertChildInternal(di);
            }
        }
        else if (item.nodeType == 3) {
            this._parseDiv.innerHTML = item.rawText;
            let element = this._parseDiv.childNodes[0];
            designItem = new DesignItem(element, item, serviceContainer, instanceServiceContainer);
        }
        else if (item.nodeType == 8) {
            let element = document.createComment(item.rawText);
            designItem = new DesignItem(element, item, serviceContainer, instanceServiceContainer);
        }
        return designItem;
    }
}
