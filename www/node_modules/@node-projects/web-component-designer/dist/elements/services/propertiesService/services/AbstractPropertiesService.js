import { ValueType } from '../ValueType.js';
import { PropertiesHelper } from './PropertiesHelper.js';
import { BindingTarget } from '../../../item/BindingTarget.js';
import { PropertyType } from '../PropertyType.js';
import { NodeType } from '../../../item/NodeType.js';
import { newElementFromString } from '../../../helper/ElementHelper.js';
export class AbstractPropertiesService {
    constructor(recreateElementsOnPropertyChange) {
        this._recreateElementsOnPropertyChange = recreateElementsOnPropertyChange;
    }
    _recreateElementsOnPropertyChange = false;
    static _stylesCache = new Map;
    _cssCacheClearTimer;
    static _bindingsCache = new Map;
    static _bindingsCacheClearTimer;
    _notifyChangedProperty(designItem, property, value) {
    }
    async getProperty(designItem, name) {
        let properties = await this.getProperties(designItem);
        if ('properties' in properties[0]) {
            return properties.flatMap(x => x.properties).find(x => x.name == name);
        }
        else
            return properties.find(x => x.name == name);
    }
    async setValue(designItems, property, value) {
        const cg = designItems[0].openGroup("property changed: " + property.name + " to " + value);
        for (let d of designItems) {
            if (!this.isHandledElement(d))
                continue;
            if (!this.getProperty(d, property.name))
                continue;
            if (property.propertyType == PropertyType.cssValue) {
                //TODO: use async version here, but then everything needs to be async
                await d.updateStyleInSheetOrLocalAsync(property.name, value);
                //unkown css property names do not trigger the mutation observer of property grid, 
                //fixed by assinging style again to the attribute
                d.element.setAttribute('style', d.element.getAttribute('style'));
            }
            else {
                let attributeName = property.attributeName;
                if (!attributeName)
                    attributeName = PropertiesHelper.camelToDashCase(property.name);
                if (property.type === 'object') {
                    const json = JSON.stringify(value);
                    if (property.propertyType == PropertyType.attribute || property.propertyType == PropertyType.propertyAndAttribute)
                        d.setAttribute(attributeName, json);
                    if (property.propertyType == PropertyType.property || property.propertyType == PropertyType.propertyAndAttribute)
                        d.element[property.name] = value;
                }
                else if (property.type == 'boolean' && (value === false || value == null)) {
                    if (property.propertyType == PropertyType.attribute || property.propertyType == PropertyType.propertyAndAttribute)
                        d.removeAttribute(attributeName);
                    if (property.propertyType == PropertyType.property || property.propertyType == PropertyType.propertyAndAttribute)
                        d.element[property.name] = false;
                }
                else if (property.type == 'boolean' && value === true) {
                    if (property.propertyType == PropertyType.attribute || property.propertyType == PropertyType.propertyAndAttribute)
                        d.setAttribute(attributeName, "");
                    if (property.propertyType == PropertyType.property || property.propertyType == PropertyType.propertyAndAttribute)
                        d.element[property.name] = true;
                }
                else {
                    if (property.propertyType == PropertyType.attribute || property.propertyType == PropertyType.propertyAndAttribute)
                        d.setAttribute(attributeName, value.toString());
                    if (property.propertyType == PropertyType.property || property.propertyType == PropertyType.propertyAndAttribute)
                        d.element[property.name] = value;
                }
            }
            this._notifyChangedProperty(d, property, value);
        }
        cg.commit();
        if (this._recreateElementsOnPropertyChange)
            AbstractPropertiesService.recreateElements(this, designItems);
    }
    getPropertyTarget(designItem, property) {
        if (property.propertyType == PropertyType.attribute)
            return BindingTarget.attribute;
        if (property.propertyType == PropertyType.cssValue)
            return BindingTarget.css;
        return BindingTarget.property;
    }
    clearValue(designItems, property, clearType) {
        const cg = designItems[0].openGroup("property cleared: " + property.name);
        for (let d of designItems) {
            if (clearType != 'binding') {
                if (property.propertyType == PropertyType.cssValue) {
                    d.removeStyle(property.name);
                }
                else {
                    let attributeName = property.attributeName;
                    if (!attributeName)
                        attributeName = PropertiesHelper.camelToDashCase(property.name);
                    d.removeAttribute(attributeName);
                }
            }
            if (clearType != 'value') {
                d.serviceContainer.forSomeServicesTillResult('bindingService', (s) => {
                    return s.clearBinding(d, property.name, this.getPropertyTarget(d, property));
                });
            }
            this._notifyChangedProperty(d, property, undefined);
        }
        cg.commit();
        if (this._recreateElementsOnPropertyChange)
            AbstractPropertiesService.recreateElements(this, designItems);
    }
    isSet(designItems, property) {
        let all = true;
        let some = false;
        if (designItems != null && designItems.length !== 0) {
            let attributeName = property.attributeName;
            if (!attributeName)
                attributeName = PropertiesHelper.camelToDashCase(property.name);
            for (let x of designItems) {
                let has = false;
                if (property.propertyType == PropertyType.cssValue)
                    has = x.hasStyle(property.name);
                else
                    has = x.hasAttribute(attributeName);
                all = all && has;
                some = some || has;
                if (!all && some)
                    break;
            }
            ;
            const bindings = AbstractPropertiesService.getOrBuildCachedBindings(designItems[0]);
            if (property.propertyType == PropertyType.cssValue) {
                if (bindings && bindings.find(x => (x.target == BindingTarget.css || x.target == BindingTarget.cssvar) && x.targetName == property.name))
                    return ValueType.bound;
            }
            else {
                if (property.propertyType == PropertyType.attribute) {
                    if (bindings && bindings.find(x => x.target == BindingTarget.attribute && x.targetName == property.name))
                        return ValueType.bound;
                }
                else if (property.propertyType == PropertyType.property) {
                    if (bindings && bindings.find(x => (x.target == BindingTarget.property || x.target == BindingTarget.explicitProperty) && x.targetName == property.name))
                        return ValueType.bound;
                }
                else {
                    if (bindings && bindings.find(x => (x.target == BindingTarget.property || x.target == BindingTarget.explicitProperty || x.target == BindingTarget.attribute) && x.targetName == property.name))
                        return ValueType.bound;
                }
            }
            if (!all && property.propertyType == PropertyType.cssValue) {
                let styles = AbstractPropertiesService._stylesCache.get(designItems[0]);
                if (!styles) {
                    styles = new Set(designItems[0].getAllStyles().filter(x => x.selector != null).flatMap(x => x.declarations).map(x => x.name));
                    AbstractPropertiesService._stylesCache.set(designItems[0], styles);
                    clearTimeout(this._cssCacheClearTimer);
                    this._cssCacheClearTimer = setTimeout(() => AbstractPropertiesService._stylesCache.clear(), 30);
                }
                let cssValue = styles.has(property.name);
                if (cssValue)
                    return ValueType.fromStylesheet;
            }
        }
        else
            return ValueType.none;
        return all ? ValueType.all : some ? ValueType.some : ValueType.none;
    }
    static getOrBuildCachedBindings(designItem) {
        let bindings = AbstractPropertiesService._bindingsCache.get(designItem);
        if (!bindings) {
            const services = designItem.serviceContainer.getServices('bindingService');
            bindings = [];
            if (services) {
                for (const s of services) {
                    const bs = s.getBindings(designItem);
                    if (bs && bs.length > 0) {
                        bindings.push(...bs);
                    }
                }
            }
            AbstractPropertiesService._bindingsCache.set(designItem, bindings);
            clearTimeout(this._bindingsCacheClearTimer);
            this._bindingsCacheClearTimer = setTimeout(() => AbstractPropertiesService._bindingsCache.clear(), 30);
        }
        return bindings;
    }
    getValue(designItems, property) {
        if (designItems != null && designItems.length !== 0) {
            if (property.propertyType == PropertyType.cssValue) {
                let lastValue = designItems[0].getStyle(property.name);
                for (const d of designItems) {
                    let value = d.getStyle(property.name);
                    if (value != lastValue) {
                        lastValue = null;
                        break;
                    }
                }
                return lastValue;
            }
            else {
                let attributeName = property.attributeName;
                if (!attributeName)
                    attributeName = PropertiesHelper.camelToDashCase(property.name);
                if (property.type == 'boolean') {
                    if (designItems[0].hasAttribute(attributeName)) {
                        const val = designItems[0].getAttribute(attributeName);
                        if (val == "")
                            return true;
                        return val;
                    }
                    return false;
                }
                let lastValue = designItems[0].getAttribute(attributeName);
                /*
                for (const x of designItems) {
                  let value = x.attributes.get(attributeName);
                  if (value != lastValue) {
                    lastValue = null;
                    break;
                  }
                }
                */
                return lastValue;
            }
        }
        return null;
    }
    getBinding(designItems, property) {
        const bindings = AbstractPropertiesService.getOrBuildCachedBindings(designItems[0]);
        if (bindings != null) {
            if (property.propertyType == PropertyType.cssValue) {
                return bindings.find(x => (x.target == BindingTarget.css || x.target == BindingTarget.cssvar) && x.targetName == property.name);
            }
            else {
                if (property.propertyType == PropertyType.attribute) {
                    return bindings.find(x => x.target == BindingTarget.attribute && x.targetName == property.name);
                }
                else if (property.propertyType == PropertyType.property) {
                    return bindings.find(x => (x.target == BindingTarget.property || x.target == BindingTarget.explicitProperty) && x.targetName == property.name);
                }
                else {
                    return bindings.find(x => (x.target == BindingTarget.property || x.target == BindingTarget.explicitProperty || x.target == BindingTarget.attribute) && x.targetName == property.name);
                }
            }
        }
        return null;
    }
    getUnsetValue(designItems, property) {
        if (property.propertyType == PropertyType.cssValue) {
            if (designItems != null && designItems.length !== 0) {
                if (designItems[0].nodeType == NodeType.Element) {
                    let v = window.getComputedStyle(designItems[0].element)[property.name];
                    return v;
                }
            }
            return null;
        }
        else
            return property.defaultValue;
    }
    static recreateElements(service, designItems) {
        for (let d of designItems) {
            if (!service.isHandledElement(d))
                continue;
            let txt = '<' + d.name + ' ';
            for (let a of d.element.attributes) {
                txt += a.name + '="' + a.value.replaceAll('"', '&quot;') + '" ';
            }
            txt += '></' + d.name + '>';
            let element = newElementFromString(txt, designItems[0].document); // some custom elements only parse attributes during constructor call 
            for (let c of [...d.element.childNodes])
                element.appendChild(c);
            element.style.pointerEvents = 'auto';
            d.node.insertAdjacentElement('beforebegin', element);
            if (d.node.parentNode)
                d.node.parentNode.removeChild(d.node);
            d.replaceNode(element);
        }
    }
    getContextMenu(designItems, property) {
        const ctxMenuItems = [
            {
                title: 'clear', action: (e) => {
                    property.service.clearValue(designItems, property, 'value');
                    designItems[0].instanceServiceContainer.designerCanvas.extensionManager.refreshAllExtensions(designItems);
                }
            },
            {
                title: 'edit as text', action: (e, _1, _2, menu) => {
                    menu.close();
                    setTimeout(async () => {
                        const oldValue = property.service.getValue(designItems, property);
                        let value = prompt(`edit value of '${property.name}' as string:`, oldValue);
                        if (value && value != oldValue) {
                            await property.service.setValue(designItems, property, value);
                        }
                        designItems[0].instanceServiceContainer.designerCanvas.extensionManager.refreshAllExtensions(designItems);
                    }, 10);
                }
            },
        ];
        if (designItems[0].serviceContainer.config.openBindingsEditor) {
            ctxMenuItems.push(...[
                { title: '-' },
                {
                    title: 'edit binding', action: () => {
                        let target = property.service.getPropertyTarget(designItems[0], property);
                        let binding = property.service.getBinding(designItems, property);
                        designItems[0].serviceContainer.config.openBindingsEditor(property, designItems, binding, target);
                    }
                }
            ]);
            if (property.service.isSet(designItems, property) == ValueType.bound) {
                ctxMenuItems.push(...[
                    {
                        title: 'clear binding', action: () => {
                            property.service.clearValue(designItems, property, 'binding');
                            designItems[0].instanceServiceContainer.designerCanvas.extensionManager.refreshAllExtensions(designItems);
                        }
                    }
                ]);
            }
        }
        ;
        return ctxMenuItems;
    }
}
//# sourceMappingURL=AbstractPropertiesService.js.map