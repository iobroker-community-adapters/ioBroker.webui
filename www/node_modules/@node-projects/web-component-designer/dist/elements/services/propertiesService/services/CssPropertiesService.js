import { BindingTarget } from '../../../item/BindingTarget.js';
import { PropertyType } from '../PropertyType.js';
import { CommonPropertiesService } from './CommonPropertiesService.js';
import { RefreshMode } from '../IPropertiesService.js';
import { PropertiesHelper } from './PropertiesHelper.js';
import { GridAssignedRowColumnPropertyEditor } from '../propertyEditors/special/GridAssignedRowColumnPropertyEditor.js';
import { MetricsPropertyEditor } from '../propertyEditors/special/MetricsPropertyEditor.js';
//TODO: remove this code when import asserts are supported
let cssProperties;
//@ts-ignore
if (window.importShim) {
    const cssPropertiesUrl = import.meta.resolve('./CssProperties.json');
    //@ts-ignore
    cssProperties = await importShim(cssPropertiesUrl, { assert: { type: 'json' } });
}
else
    //@ts-ignore
    cssProperties = await import("./CssProperties.json", { assert: { type: 'json' } });
if (cssProperties.default)
    cssProperties = cssProperties.default;
export class CssPropertiesService extends CommonPropertiesService {
    getRefreshMode(designItem) {
        return RefreshMode.none;
    }
    //metrics
    layout = [
        "display",
        "color",
        "background-color",
        "box-sizing",
        "border",
        "box-shadow",
        "opacity",
        "position",
        "font-size",
        "font-weight",
        "inset",
        "margin",
        "border",
        "padding",
        "overflow",
        "metrics"
    ];
    grid = [
        "display",
        "position",
        "grid-template-columns",
        "grid-template-rows",
        "column-gap",
        "row-gap",
        "align-content",
        "justify-content",
        "align-items",
        "justify-items",
    ];
    gridChild = [
        "grid-row",
        "grid-column",
        "assigned-row-column",
        "align-self",
        "justify-self"
    ];
    flex = [
        "display",
        "position",
        "flex-direction",
        "flex-wrap",
        "align-content",
        "justify-content",
        "align-items"
    ];
    flexChild = [
        "align-self",
        "justify-self"
    ];
    svg = [
        "fill",
        "fill-rule",
        "fill-opacity",
        "stroke",
        "stroke-width",
        "stroke-dash-array",
        "stroke-opacity"
    ];
    constructor(name) {
        super();
        this.name = name;
    }
    isHandledElement(designItem) {
        return true;
    }
    getProperty(designItem, name) {
        return this[this.name][name];
    }
    getProperties(designItem) {
        const propNames = this[this.name];
        const propertiesList = propNames.map(x => this._getPropertyDef(x));
        return propertiesList;
    }
    _getPropertyDef(name) {
        const camelName = PropertiesHelper.dashToCamelCase(name);
        switch (camelName) {
            case 'assignedRowColumn':
                return { name, service: this, propertyType: PropertyType.complex, createEditor: (p) => new GridAssignedRowColumnPropertyEditor(p) };
            case 'metrics':
                return { name, service: this, propertyType: PropertyType.complex, createEditor: (p) => new MetricsPropertyEditor(p) };
            default:
                return {
                    name,
                    type: cssProperties[camelName]?.type ?? 'string',
                    values: cssProperties[camelName]?.values ? [...cssProperties[camelName]?.values, 'initial', 'inherit', 'unset'] : ['initial', 'inherit', 'unset'],
                    service: this,
                    propertyType: PropertyType.cssValue
                };
        }
    }
    getPropertyTarget(designItem, property) {
        return BindingTarget.css;
    }
}
