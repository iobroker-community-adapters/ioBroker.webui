import { AbstractStylesheetService } from "./AbstractStylesheetService.js";
export class CssToolsStylesheetService extends AbstractStylesheetService {
    constructor(designerCanvas) {
        super(designerCanvas);
    }
    _tools;
    async internalParse(style) {
        if (!this._tools)
            this._tools = await import('@adobe/css-tools');
        return this._tools.parse(style);
    }
    getAppliedRules(designItem) {
        let rules = [];
        for (let item of this._allStylesheets.entries()) {
            if (!item[1].ast?.stylesheet?.rules)
                continue;
            let rs = Array.from(this.getRulesFromAst(item[1].ast?.stylesheet?.rules, item[1].stylesheet, designItem))
                .map(x => ({
                selector: x.selectors.join(', '),
                declarations: x.declarations.filter(y => y.type == 'declaration').map(y => ({
                    name: y.property,
                    value: y.value.endsWith('!important') ? y.value.substring(0, y.value.length - 10).trimEnd() : y.value,
                    important: y.value.endsWith('!important'),
                    parent: null,
                    ast: y,
                    stylesheet: item[1].stylesheet
                })),
                specificity: 0,
                stylesheetName: item[0],
                ast: x,
            }));
            rs.forEach(x => x.declarations.forEach(y => y.parent = x));
            rules.push(...rs);
        }
        ;
        return rules;
    }
    *getRulesFromAst(cssAtRuleAst, stylesheet, designItem) {
        for (const atRule of cssAtRuleAst) {
            if (atRule.type == 'media') {
                yield* this.getRulesFromAst(atRule.rules, stylesheet, designItem);
            }
            else if (atRule.type == 'supports') {
                yield* this.getRulesFromAst(atRule.rules, stylesheet, designItem);
            }
            else if (atRule.type == 'rule') {
                if (this.elementMatchesASelector(designItem, atRule.selectors))
                    yield atRule;
            }
        }
        return null;
    }
    getDeclarations(designItem, styleName) {
        return this.getAppliedRules(designItem).flatMap(x => x.declarations).filter(x => x.name == styleName);
    }
    updateDeclarationValueWithoutUndo(declaration, value, important) {
        declaration.ast.value = important ? value + ' !important' : value;
        let ss = this._allStylesheets.get(declaration.parent.stylesheetName);
        this.updateStylesheet(ss);
        /*
        declaration.ast.value = important ? value + ' !important' : value;
        let ss = declaration.ast;
        while (ss?.parent)
            ss = ss?.parent;
        let obj = { ast: ss, stylesheet: declaration.stylesheet };
        this._allStylesheets.set(declaration.parent.stylesheetName, obj)
        this.updateStylesheet(obj);
        */
    }
    insertDeclarationIntoRule(rule, property, value, important) {
        rule.ast.declarations.push({
            type: 'declaration',
            property: property,
            value: important ? value + ' !important' : value
        });
        this.updateStylesheet(this._allStylesheets.get(rule.stylesheetName));
        return true;
    }
    removeDeclarationFromRule(rule, property) {
        let idx = rule.ast.declarations.findIndex(x => x.property == property);
        if (idx == -1)
            return false;
        rule.ast.declarations.splice(idx, 1);
        this.updateStylesheet(this._allStylesheets.get(rule.stylesheetName));
        return true;
    }
    updateStylesheet(ss) {
        const old = ss.stylesheet.content;
        ss.stylesheet.content = this._tools.stringify(ss.ast, { indent: '    ', compress: false, emptyDeclarations: true });
        if (ss.stylesheet.designItem) {
            ss.stylesheet.designItem.content = ss.stylesheet.content;
        }
        else
            this.stylesheetChanged.emit({ name: ss.stylesheet.name, newStyle: ss.stylesheet.content, oldStyle: old, changeSource: 'styleupdate' });
    }
    updateCompleteStylesheet(name, newStyle) {
        this.updateCompleteStylesheetInternal(name, newStyle, 'styleupdate');
    }
    updateCompleteStylesheetWithoutUndo(name, newStyle, noUndo = false) {
        this.updateCompleteStylesheetInternal(name, newStyle, 'undo');
    }
    updateCompleteStylesheetInternal(name, newStyle, changeSource) {
        const ss = this._allStylesheets.get(name);
        if (ss.stylesheet.content != newStyle) {
            const old = ss.stylesheet.content;
            ss.stylesheet.content = newStyle;
            if (ss.stylesheet.designItem) {
                ss.stylesheet.designItem.content = ss.stylesheet.content;
            }
            else
                this.stylesheetChanged.emit({ name: ss.stylesheet.name, newStyle: ss.stylesheet.content, oldStyle: old, changeSource });
        }
    }
}
