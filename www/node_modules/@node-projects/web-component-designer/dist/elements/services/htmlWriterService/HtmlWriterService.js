import { DomConverter } from '../../widgets/designerView/DomConverter.js';
import { CssCombiner } from '../../helper/CssCombiner.js';
import { NodeType } from '../../item/NodeType.js';
import { PropertiesHelper } from '../propertiesService/services/PropertiesHelper.js';
import { isInline } from '../../helper/ElementHelper.js';
export class HtmlWriterService {
    canWrite(designItem) {
        return true;
    }
    _conditionalyWriteIndent(indentedTextWriter, designItem) {
        if ((designItem.element instanceof HTMLElement && !isInline(designItem.element)) ||
            (designItem.element.previousElementSibling instanceof HTMLElement && !isInline(designItem.element.previousElementSibling)))
            indentedTextWriter.writeIndent();
    }
    _conditionalyWriteNewline(indentedTextWriter, designItem) {
        if ((designItem.element instanceof HTMLElement && !isInline(designItem.element)) ||
            (designItem.element.nextElementSibling instanceof HTMLElement && !isInline(designItem.element.nextElementSibling)))
            indentedTextWriter.writeNewline();
    }
    write(indentedTextWriter, designItem, options, designItemsAssignmentList) {
        let start = indentedTextWriter.position;
        if (designItem.nodeType == NodeType.TextNode) {
            this.writeTextNode(indentedTextWriter, designItem, true);
        }
        else if (designItem.nodeType == NodeType.Comment) {
            this._conditionalyWriteIndent(indentedTextWriter, designItem);
            indentedTextWriter.write('<!--' + designItem.content + '-->');
            this._conditionalyWriteNewline(indentedTextWriter, designItem);
        }
        else {
            this._conditionalyWriteIndent(indentedTextWriter, designItem);
            indentedTextWriter.write('<' + designItem.name);
            if (designItem.hasAttributes) {
                for (const a of designItem.attributes) {
                    indentedTextWriter.write(' ');
                    if (typeof a[1] === 'string') {
                        if (a[1] === "")
                            indentedTextWriter.write(a[0]);
                        else
                            indentedTextWriter.write(a[0] + '="' + DomConverter.normalizeAttributeValue(a[1]) + '"');
                    }
                    else if (!a[1])
                        indentedTextWriter.write(a[0]);
                    else {
                        //TODO: writing of bindings
                    }
                }
            }
            if (designItem.hasStyles) {
                indentedTextWriter.write(' style="');
                let styles = designItem.styles;
                if (options.compressCssToShorthandProperties)
                    styles = CssCombiner.combine(styles);
                for (const s of styles) {
                    if (s[0]) {
                        indentedTextWriter.write(PropertiesHelper.camelToDashCase(s[0]) + ':' + DomConverter.normalizeAttributeValue(s[1]) + ';');
                    }
                }
                indentedTextWriter.write('"');
            }
            indentedTextWriter.write('>');
            if (designItem.hasChildren) {
                const children = designItem.children();
                const singleTextNode = designItem.childCount === 1 && designItem.firstChild.nodeType === NodeType.TextNode;
                if (singleTextNode) {
                    this.writeTextNode(indentedTextWriter, designItem, false);
                }
                else {
                    indentedTextWriter.writeNewline();
                    indentedTextWriter.levelRaise();
                    for (const c of children) {
                        c.serviceContainer.forSomeServicesTillResult('htmlWriterService', (s) => {
                            if (s.canWrite(c)) {
                                s.write(indentedTextWriter, c, options, designItemsAssignmentList);
                            }
                        });
                    }
                    indentedTextWriter.levelShrink();
                    indentedTextWriter.writeIndent();
                }
            }
            else if (designItem.hasContent) {
                indentedTextWriter.write(DomConverter.normalizeContentValue(designItem.content));
            }
            if (!DomConverter.IsSelfClosingElement(designItem.name))
                indentedTextWriter.write('</' + designItem.name + '>');
            this._conditionalyWriteNewline(indentedTextWriter, designItem);
        }
        if (designItemsAssignmentList) {
            designItemsAssignmentList.set(designItem, { start: start, length: indentedTextWriter.position - start - 1 });
        }
    }
    writeTextNode(indentedTextWriter, designItem, indentAndNewline) {
        let content = DomConverter.normalizeContentValue(designItem.content).trim();
        if (content) {
            if (indentAndNewline)
                this._conditionalyWriteIndent(indentedTextWriter, designItem);
            indentedTextWriter.write(content);
            if (indentAndNewline)
                this._conditionalyWriteNewline(indentedTextWriter, designItem);
        }
    }
}
