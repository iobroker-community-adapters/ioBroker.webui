import { CalculateGridInformation, GetElementGridInformation } from '../../helper/GridHelper.js';
import { pointInRect } from '../../helper/Helper.js';
import { DefaultPlacementService } from './DefaultPlacementService.js';
export class GridPlacementService {
    _basePlacementService;
    constructor(basePlacementService) {
        this._basePlacementService = basePlacementService ?? new DefaultPlacementService();
    }
    enterContainer(container, items) {
        for (let i of items) {
            i.removeStyle("position");
            i.removeStyle("left");
            i.removeStyle("top");
            i.removeStyle("right");
            i.removeStyle("width");
            i.removeStyle("height");
            i.removeStyle("transform");
        }
    }
    leaveContainer(container, items) {
        for (let i of items) {
            if (!i.lastContainerSize) {
                const rect = i.element.getBoundingClientRect();
                i.lastContainerSize = { width: rect.width, height: rect.height };
            }
        }
    }
    serviceForContainer(container, containerStyle) {
        if (containerStyle.display == 'grid' || containerStyle.display == 'inline-grid')
            return true;
        return false;
    }
    isEnterableContainer(container) {
        return this._basePlacementService.isEnterableContainer(container);
    }
    canEnter(container, items) {
        return this._basePlacementService.canEnter(container, items);
    }
    canLeave(container, items) {
        return true;
    }
    getElementOffset(container, designItem) {
        return container.element.getBoundingClientRect();
    }
    placePoint(event, placementView, container, startPoint, offsetInControl, newPoint, items) {
        const defaultPlacementService = container.serviceContainer.getLastServiceWhere('containerService', x => x instanceof DefaultPlacementService);
        return defaultPlacementService.placePoint(event, placementView, container, startPoint, offsetInControl, newPoint, items);
    }
    startPlace(event, placementView, container, startPoint, offsetInControl, newPoint, items) {
    }
    place(event, placementView, container, startPoint, offsetInControl, newPoint, items) {
        const gridInformation = CalculateGridInformation(container);
        const pos = placementView.getNormalizedEventCoordinates(event);
        let row = 0;
        let column = 0;
        for (let cellRow of gridInformation.cells) {
            column = 0;
            for (let cell of cellRow) {
                if (pointInRect(pos, cell)) {
                    let info = GetElementGridInformation(items[0].element);
                    if (cell.name) {
                        items[0].element.style.gridColumn = '';
                        items[0].element.style.gridRow = '';
                        items[0].element.style.gridArea = cell.name;
                    }
                    else {
                        items[0].element.style.gridArea = '';
                        items[0].element.style.gridColumn = (column + 1) + (info.colSpan > 1 ? ' / span ' + info.colSpan : '');
                        items[0].element.style.gridRow = (row + 1) + (info.rowSpan > 1 ? ' / span ' + info.rowSpan : '');
                    }
                }
                column++;
            }
            row++;
        }
        placementView.extensionManager.refreshAllExtensions([container]);
    }
    finishPlace(event, placementView, container, startPoint, offsetInControl, newPoint, items) {
        const gridInformation = CalculateGridInformation(container);
        const pos = placementView.getNormalizedEventCoordinates(event);
        let row = 0;
        let column = 0;
        row = 0;
        for (let cellRow of gridInformation.cells) {
            column = 0;
            for (let cell of cellRow) {
                if (pointInRect(pos, cell)) {
                    let info = GetElementGridInformation(items[0].element);
                    //Grid Area is shorthand for grid row/column, to make undo work correctly we need to set befor and after clear
                    if (cell.name) {
                        items[0].setStyle('grid-area', cell.name);
                        items[0].removeStyle('grid-column');
                        items[0].removeStyle('grid-row');
                        items[0].setStyle('grid-area', cell.name);
                    }
                    else {
                        items[0].setStyle('grid-column', (column + 1) + (info.colSpan > 1 ? ' / span ' + info.colSpan : ''));
                        items[0].setStyle('grid-row', (row + 1) + (info.rowSpan > 1 ? ' / span ' + info.rowSpan : ''));
                        items[0].removeStyle('grid-area');
                        items[0].setStyle('grid-column', (column + 1) + (info.colSpan > 1 ? ' / span ' + info.colSpan : ''));
                        items[0].setStyle('grid-row', (row + 1) + (info.rowSpan > 1 ? ' / span ' + info.rowSpan : ''));
                    }
                }
                column++;
            }
            row++;
        }
        placementView.extensionManager.refreshAllExtensions([container]);
    }
    moveElements(designItems, position, absolute) {
    }
}
