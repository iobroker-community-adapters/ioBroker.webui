export function customElement(tagname) {
    return function (class_) {
        //@ts-ignore
        class_.is = tagname;
        customElements.define(tagname, class_);
    };
}
globalThis.baseCustomWebComponentPropertyMetadata ??= new WeakMap();
const legacyProperty = (par, proto, name) => {
    //@ts-ignore
    if (!proto.constructor.properties) {
        //@ts-ignore
        proto.constructor.properties = {};
    }
    if (par && par.type != null) {
        //@ts-ignore
        proto.constructor.properties[name] = par.type ? par.type : String;
    }
    else {
        //@ts-ignore
        proto.constructor.properties[name] = par ? par : String;
    }
};
const defaultPropertyDefinition = {
    attribute: true,
    type: String,
    reflect: false
};
/*
const standardProperty = <C extends Interface<BaseCustomWebComponentNoAttachedTemplate>, V>(
  options: propertyDefinition = defaultPropertyDefinition,
  target: ClassAccessorDecoratorTarget<C, V> | ((value: V) => void),
  context: StandardPropertyContext<C, V>
): ClassAccessorDecoratorResult<C, V> | ((this: C, value: V) => void) => {
  const {kind, metadata} = context;

  if (metadata == null) {
    throw new Error('missing-class-metadata or polyfill-symbol-metadata');
  }

  let properties = globalThis.litPropertyMetadata.get(metadata);
  if (properties === undefined) {
    globalThis.litPropertyMetadata.set(metadata, (properties = new Map()));
  }
  if (kind === 'setter') {
    options = Object.create(options);
    //options.wrapped = true;
  }
  properties.set(context.name, options);

  if (kind === 'accessor') {
    const {name} = context;
    return {
      set(this: BaseCustomWebComponentNoAttachedTemplate, v: V) {
        const oldValue = (
          target as ClassAccessorDecoratorTarget<C, V>
        ).get.call(this as unknown as C);
        (target as ClassAccessorDecoratorTarget<C, V>).set.call(
          this as unknown as C,
          v
        );
        //this.requestUpdate(name, oldValue, options);
      },
      init(this: BaseCustomWebComponentNoAttachedTemplate, v: V): V {
        if (v !== undefined) {
          this._$changeProperty(name, undefined, options, v);
        }
        return v;
      },
    } as unknown as ClassAccessorDecoratorResult<C, V>;
  } else if (kind === 'setter') {
    const {name} = context;
    return function (this: BaseCustomWebComponentNoAttachedTemplate, value: V) {
      const oldValue = this[name as keyof ReactiveElement];
      (target as (value: V) => void).call(this, value);
      this.requestUpdate(name, oldValue, options);
    } as unknown as (this: C, value: V) => void;
  }
  throw new Error(`Unsupported decorator location: ${kind}`);
};
*/
const standardProperty = (options, target, context) => {
    const { metadata } = context;
    if (metadata == null) {
        throw new Error('missing-class-metadata or polyfill-symbol-metadata');
    }
    let properties = globalThis.baseCustomWebComponentPropertyMetadata.get(metadata);
    if (properties === undefined) {
        globalThis.baseCustomWebComponentPropertyMetadata.set(metadata, (properties = new Map()));
    }
    throw new Error('new decorators not yet supported! (need work)');
};
// Implementation
export function property(options) {
    return (protoOrTarget, nameOrContext) => {
        if (typeof nameOrContext === "object") {
            // ✅ Standard decorator path
            return standardProperty(options ?? defaultPropertyDefinition, protoOrTarget, nameOrContext);
        }
        else {
            // ✅ Legacy decorator path
            return legacyProperty(options, protoOrTarget, nameOrContext);
        }
    };
}
