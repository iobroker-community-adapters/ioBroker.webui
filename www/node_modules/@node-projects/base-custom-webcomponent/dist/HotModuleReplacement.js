import { BaseCustomWebComponentNoAttachedTemplate } from "./BaseCustomWebComponent.js";
export function getFunctionType(x) {
    return typeof x === 'function'
        ? x.prototype
            ? Object.getOwnPropertyDescriptor(x, 'prototype').writable
                ? 'function'
                : 'class'
            : x.constructor.name === 'AsyncFunction'
                ? 'async'
                : 'arrow'
        : '';
}
export class HotModuleReplacement {
    static { this.instances = []; }
    static enableHMR() {
        BaseCustomWebComponentNoAttachedTemplate.instanceCreatedCallback = (i) => {
            HotModuleReplacement.instances.push(new WeakRef(i));
        };
    }
    static initHMR(fetchChangedFiles) {
        HotModuleReplacement.changesFetcher = fetchChangedFiles;
        BaseCustomWebComponentNoAttachedTemplate.instanceCreatedCallback = (i) => {
            HotModuleReplacement.instances.push(new WeakRef(i));
        };
        HotModuleReplacement.startPolling();
    }
    static startPolling(interval = 100) {
        setTimeout(() => {
            HotModuleReplacement.pollForChanges(interval);
        }, interval);
    }
    static async pollForChanges(interval) {
        let changes = await HotModuleReplacement.changesFetcher();
        if (changes != null) {
            HotModuleReplacement.assertChangedFiles(changes);
        }
        setTimeout(() => {
            HotModuleReplacement.pollForChanges(interval);
        }, interval);
    }
    static assertChangedFiles(changes) {
        if (changes != null) {
            for (let file of changes) {
                HotModuleReplacement.assertFileType(file);
            }
        }
    }
    static assertFileType(file) {
        switch (file.trim().toLowerCase().split(".").pop()) {
            case "css":
                console.warn("ðŸ”¥ Hot reload - css: " + file);
                HotModuleReplacement.reloadCss(file);
                break;
            case "js":
            case "cjs":
            case "mjs":
                console.warn("ðŸ”¥ Hot reload - js: " + file);
                HotModuleReplacement.reloadJs(file);
                break;
            default:
                break;
        }
    }
    static async reloadJs(file) {
        let oldModule = await import(file);
        let oldDefine = customElements.define;
        customElements.define = () => null;
        let newModule = await import(file + "?reload=" + new Date().getTime());
        customElements.define = oldDefine;
        for (let nameOfexport in newModule) {
            const classExport = newModule[nameOfexport];
            if (getFunctionType(classExport) == 'class') {
                let oldConstructor = null;
                let i = HotModuleReplacement.instances.length;
                while (i--) {
                    let instanceRef = HotModuleReplacement.instances[i];
                    let instance = instanceRef.deref();
                    if (instance) {
                        if (classExport.name == instance.constructor.name) {
                            if (instance._hmrCallback)
                                instance._hmrCallback(classExport);
                            else {
                                let oldIdx = -1;
                                oldConstructor = instance.constructor;
                                if (instance.constructor.style) {
                                    oldIdx = instance.shadowRoot.adoptedStyleSheets.indexOf(instance.constructor.style);
                                    if (oldIdx >= 0) {
                                        let newArr = Array.from(instance.shadowRoot.adoptedStyleSheets);
                                        newArr.splice(oldIdx, 1);
                                        instance.shadowRoot.adoptedStyleSheets = newArr;
                                    }
                                }
                                if (classExport.style) {
                                    if (oldIdx >= 0) {
                                        let newArr = Array.from(instance.shadowRoot.adoptedStyleSheets);
                                        //@ts-ignore
                                        newArr.splice(oldIdx, 0, classExport.style);
                                        instance.shadowRoot.adoptedStyleSheets = newArr;
                                    }
                                }
                                if (instance._bindings) {
                                    instance.constructor.template = classExport.template;
                                    instance._rootDocumentFragment = document.importNode(instance.constructor.template.content, true);
                                    instance.shadowRoot.innerHTML = '';
                                    instance.shadowRoot.appendChild(instance._rootDocumentFragment);
                                    instance._bindings = null;
                                    instance._bindingsParse();
                                }
                            }
                        }
                    }
                    else {
                        HotModuleReplacement.instances.splice(i, 1);
                    }
                }
                if (oldConstructor)
                    oldConstructor.constructor.style = classExport.style;
            }
        }
        for (let nameOfexport in oldModule) {
            const oExport = oldModule[nameOfexport];
            if (getFunctionType(oExport) == 'class') {
                const newExport = newModule[nameOfexport];
                if (newExport) {
                    // Gets all attribute-properties of class
                    let properties = Object.getOwnPropertyNames(oExport);
                    for (let property of properties) {
                        if (property == 'prototype' || property == 'name' || property == 'length')
                            continue;
                        delete oExport[property];
                        try {
                            oExport[property] = newExport[property];
                        }
                        catch (err) {
                            console.error("ðŸ”¥ Hot reload - error setting property '" + property + "' of '" + oExport.name + "'", err);
                        }
                    }
                    properties = Object.getOwnPropertyNames(oExport.prototype);
                    for (let property of properties) {
                        if (property == 'prototype' || property == 'name' || property == 'length')
                            continue;
                        delete oExport[property];
                        try {
                            oExport.prototype[property] = newExport.prototype[property];
                        }
                        catch (err) {
                            console.error("ðŸ”¥ Hot reload - error setting property '" + property + "' of '" + oExport.name + "'", err);
                        }
                    }
                }
            }
        }
    }
    // Change the url of the stylesheet to force a reload
    static async reloadCss(file) {
        const newId = new Date().getTime();
        for (let link of document.querySelectorAll(`link[href*="${file}"]`))
            link.href = link.href.split("?")[0] + "?reload=" + newId;
        const oldCssModule = await import(file, { assert: { type: 'css' } });
        const newCssModule = await import(file + "?reload=" + newId, { assert: { type: 'css' } });
        const oldStylesheet = oldCssModule.default;
        const newStylesheet = newCssModule.default;
        oldStylesheet.replace(Array.from(newStylesheet.cssRules).map(rule => rule.cssText).join(''));
    }
}
