export declare const html: (strings: TemplateStringsArray, ...values: any[]) => HTMLTemplateElement;
export declare const htmlFromString: (value: string) => HTMLTemplateElement;
export declare const css: (strings: TemplateStringsArray, ...values: any[]) => CSSStyleSheet;
export declare const cssFromString: (value: string | CSSStyleSheet | any) => CSSStyleSheet;
type propertySimpleDefinition = Object | BooleanConstructor | DateConstructor | NumberConstructor | StringConstructor | ArrayConstructor | ObjectConstructor;
type propertyComplexDefinition = {
    type: propertySimpleDefinition;
};
type propertyDefinition = propertyComplexDefinition | propertySimpleDefinition;
export declare function property(par?: propertyDefinition): (target: Object, propertyKey: PropertyKey) => void;
export declare function customElement(tagname: string): (class_: new (...par: any[]) => BaseCustomWebComponentNoAttachedTemplate) => void;
type repeatBindingItem = {
    name: string;
    item: any;
};
export declare class BaseCustomWebComponentNoAttachedTemplate extends HTMLElement {
    static readonly style: CSSStyleSheet | Promise<CSSStyleSheet>;
    static readonly template: HTMLTemplateElement;
    protected _bindings: [binding: ((firstRun?: boolean, onlyWhenChanged?: boolean) => void), name: string][];
    protected _repeatBindings: WeakMap<Node, [binding: ((firstRun?: boolean) => void), name: string][]>;
    protected _rootDocumentFragment: DocumentFragment;
    protected _initialPropertyCache: Map<string, any>;
    protected _noWarningOnBindingErrors: any;
    protected _getDomElement<T extends Element>(id: string): T;
    protected _getDomElements<T extends Element>(selector: string): T[];
    protected _assignEvents(node?: Node): void;
    /**
     * Parses Polymer like Bindings
     *
     * use [[expression]] for one way bindings
     *
     * use {{this.property::change;paste}} for two way wich binds to events 'change 'and 'paste'
     *
     * use @eventname="eventHandler" to bind a handler to a event
     * or @eventname="[[this.eventHandler(par1, par2, ..)]]" for complexer event logic
     * use @touch:contextmenu... for a context menu that also works with long press on touch
     *
     * use css:cssPropertyName=[[expression]] to bind to a css property
     *
     * use class:className=[[boolExpression]] to set/remove a css class
     *
     * sub <template></template> elements are not bound, so elemnts like <iron-list> of polymer also work
     *
     * use repeat:nameOfItem=[[enumerableExpression]] on a Template Element to repeate it for every instance of the enumarable
     * ==> this could also be nested
     *
     */
    protected _bindingsParse(node?: Node, removeAttributes?: boolean, host?: any, context?: any): void;
    private _bindingsInternalParse;
    private _textFragmentBinding;
    private _bindingRunEval;
    private _bindingRunEvalInt;
    private _bindingRepeat;
    private _bindingSetNodeValue;
    private _bindingSetElementCssValue;
    private _bindingSetElementClass;
    protected _bindingsRefresh(property?: string, onlyWhenChanged?: boolean): void;
    protected _bindingsSetValue(obj: any, path: string, value: any, context: any, repeatBindingItems?: repeatBindingItem[]): void;
    private static _propertiesDictionary;
    protected _parseAttributesToProperties(noBindings?: boolean): void;
    protected _waitForChildrenReady(): Promise<void>;
    protected _restoreCachedInititalValues(): void;
    protected _restoreCachedInititalValue(name: string): void;
    static instanceCreatedCallback: (i: BaseCustomWebComponentNoAttachedTemplate) => void;
    _hmrCallback(newClass: BaseCustomWebComponentNoAttachedTemplate): void;
    constructor(template?: HTMLTemplateElement, style?: CSSStyleSheet);
}
export declare class BaseCustomWebComponentLazyAppend extends BaseCustomWebComponentNoAttachedTemplate {
    constructor(template?: HTMLTemplateElement, style?: CSSStyleSheet);
}
export declare class BaseCustomWebComponentConstructorAppend extends BaseCustomWebComponentNoAttachedTemplate {
    constructor(template?: HTMLTemplateElement, style?: CSSStyleSheet);
}
export declare class BaseCustomWebComponentLazyAppendConnectedReady extends BaseCustomWebComponentNoAttachedTemplate {
    constructor(template?: HTMLTemplateElement, style?: CSSStyleSheet);
    protected _isReady: boolean;
    connectedCallback(): void;
}
export declare class BaseCustomWebComponentConnectedReady extends BaseCustomWebComponentNoAttachedTemplate {
    constructor(template?: HTMLTemplateElement, style?: CSSStyleSheet);
    protected _isReady: boolean;
    connectedCallback(): void;
}
export declare class BaseCustomWebComponentConstructorAppendLazyReady extends BaseCustomWebComponentNoAttachedTemplate {
    constructor(template?: HTMLTemplateElement, style?: CSSStyleSheet);
}
export {};
